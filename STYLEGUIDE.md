# STYLEGUIDE

## Дисклеймер

**ВАЖНО:**
К гайду нужно относиться не как к строгому своду правил, а как к опытному советнику. Соблюдаем правила не ради правил, а
чтобы получать классный код, отвечающий современным требованиям. Хорошо написанный код ускорит понимание, а значит и
разработку продукта.

## Оглавление

- [Общие рекомендации и правила написания кода](#общие-рекомендации-и-правила-написания-кода)
    - [1. PEP-8](#1-pep-8)
    - [2. Нейминг переменных и классов](#2-нейминг-переменных-и-классов)
    - [3. Тайпхинты](#3-тайпхинты)
    - [4. Docstrings](#4-docstrings)
- [Линтеры, pre-commit](#линтеры-pre-commit)
    - [Описание линтеров и форматтеров](#описание-линтеров-и-форматтеров)
    - [pre-commit](#pre-commit)
- [Poetry](#poetry)
  - [Установка poetry](#установка-poetry)
  - [Работа с зависимостями](#работа-с-зависимостями)
- [Alembic](#alembic)
  - [Команды](#команды)
- [работа с GIT](#работа-с-git)
  - [Нейминг веток](#нейминг-веток)
  - [Pull Request](#pull-request)
- [Архитектура](#архитектура)

## Общие рекомендации и правила написания кода

### **1. PEP-8.**

Мы любим и соблюдаем [PEP-8](https://peps.python.org/pep-0008/). А контролировать нас и помогать нам его соблюдать будут
линтеры и
форматтеры ([flake8](https://flake8.pycqa.org/en/latest/), [black](https://black.readthedocs.io/en/stable/), [isort](https://pycqa.github.io/isort/)),
но об этом позже.

### **2. Нейминг переменных и классов.**

Как назвать переменную, класс или модуль зависит от вашего вкуса, однако рекомендуется придерживаться следующих
рекомендаций:

- Имя переменной, функции или класса должно сообщить, почему эта переменная существует, что она делает и как
  используется. Если имя требует дополнительных комментариев, значит, оно не передает намерений программиста. Лучше
  написать, что именно измеряется и в каких именно единицах.

        Плохие имена: a, b, k, v, wb, days
        Хорошие имена: key, value, days_since_creation

- Имена переменных `snake_case`, классов - в `CamelCase`
- Имена методов представляют собой глаголы или глагольные словосочетания: `payment_post`, `page_delete`, `save` и т.
  Шаблон такой - `<сущность>_<действие>`.

Поначалу это кажется странным, но у такого подхода есть несколько приятных особенностей:

- ***Расстановка имен.*** Легко заметить все сервисы, начинающиеся с `user_`, и хорошая идея - поместить их в
  модуль `users.py`.
- ***Удобство поиска.*** Другими словами, если вы хотите просмотреть все действия для конкретной сущности, просто вбейте
  в поиск `user_`.

### **3. Тайпхинты.**

Да, Python - язык с динамической типизацией, НО! есть огромная польза в тайпхинтах - другим разработчикам проще вникнуть
в проект, имея понимание что именно принимает данная функиция и что она возвращает; Ваша IDE подскажет Вам при
разработке какие методы есть у той или иной переменной (например передаваемой в функцию) на основе тайп хинта и т.д.
Type hints — это мощный инструмент, который может значительно улучшить код и процесс разработки.

> FastAPI по стандарту использует тайпхинты для представления объектов. Поэтому в участках кода относящихся к FastAPI
> прописывать их обязательно. Так же следует прописывать какой тип принимает и возвращает функция.

<details><summary>Полезные ссылки по тайпхинтам, для тех кто мало с ними знаком.</summary>

[Статьи на Habr.com "Введение в аннотации типов"](https://habr.com/ru/companies/lamoda/articles/432656)

Прочие полезные ссылки по тайп хинтам:

https://mypy.readthedocs.io/en/stable/index.html  - документация mypy

https://docs.python.org/3/library/typing.html  - документация пакета typing

https://mypy.readthedocs.io/en/stable/config_file.html#confval-mypy_path  - mypy_path настройка

https://github.com/python/typeshed  - typeshed - стабы для mypy

https://docs.pydantic.dev/  - pydantic - библиотека Python, которая предоставляет ряд функций проверки и анализа данных.

</details>

Рекомендации по тайпхинтингу:

1. Удовлетворить [mypy](https://www.mypy-lang.org) :) - если у Вас это получилось - вы на правильном пути;
2. Типизировать каждую переменную не нужно, однако зачастую mypy по стандарту требует типизации создаваемых коллекций (
   dict, list, tuple и т.д.), _но я постараюсь это отключить_;
3. В качестве тайп хинтов можно использовать любые встроенные и пользовательские типы (классы) в python: int, float,
   str, bytes, bool, None, object, type и так далее. Для анотации типов коллекций из модуля `typing`, так и встроенные
   коллекции-дженерики (при версии python 3.9 и выше):

        typing.List[int, str] = list[int, str]
        typing.Dict[int, str] = dict[int, str]
        typing.Optional[int] = int | None
        typing.Union[int, str] = int | str 

> Тут дело привычки и что использовать - решать Вам, главное чтобы это было правильно, но я предпочитаю второй вариант

4. Избегать аннотации `Any` - почти всегда разработчик должен знать и понимать что вернет его функция или метод класса (
   или что ему нужно принять). Исключения редки, но они бывают. И чтобы их было как можно меньше старайтесь по максимуму
   использовать функционал модуля [typing](https://docs.python.org/3/library/typing.html).

### **4. Docstrings.**

Докстринги должны быть у всех функций, классов, методов классов (за исключением "магических"). Основная цель докстрингов - дополнить название и дать другим разработчикам понять для чего предназначен и как работает тот или инной метод/функция.

> В нашем проекте язык докстрингов будет `русский`. Формат любой, после рефакторинга придём к единому стилю

#### Комментарии TODO и FIXME

Пишем комментарии TODO и FIXME, когда вспоминаем что-то важное
в процессе работы над фичей и не хотим отвлекаться,
но перед коммитом всё вычищаем: фиксим или создаём тикеты в трекере задач.

> Задачам по доработке и рефакторингу закидываем в трекере задач, а не в код.

[⬆️ К оглавлению](#оглавление)
## Poetry
Poetry — простой и удобный инструмент, который упрощает ведение и разработку проекта (прокаченный pip).

[Хороший гайд по Poetry](https://habr.com/ru/articles/593529/)

### Установка poetry
Для установки достаточно установить его через pip:
```bash
pip install poetry
```
Для активации poetry нужно прописать:
```bash
poetry install
```

### Работа с зависимостями
Обновления зависимостей (при загрузки обновлений репозитория с GitHub):
```bash
poetry update
```
Добавление зависимости:
```bash
poetry add PACKAGE_NAME
```
Удаление зависимости:
```bash
poetry remove PACKAGE_NAME
```
Вывод дерева зависимостей:
```bash
poetry show --tree
```
Экспорт зависимостей в `requirements.txt`:
```bash
poetry export --without-hashes --format=requirements.txt > requirements.txt
```
[⬆️ К оглавлению](#оглавление)

## Линтеры, pre-commit

Использование линтеров и pre-commit хуков является хорошей практикой, помогающей писать чистый и понятный код. Подробнее
про `git hooks` можно почитать [тут](https://git-scm.com/book/ru/v2/%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-Git-%D0%A5%D1%83%D0%BA%D0%B8-%D0%B2-Git), что такое пакет `pre-commit` - [тут](https://pre-commit.com).

### Описание линтеров и форматтеров

В нашем проекте будем использовать следующие линтеры и форматеры:

- [isort](https://pycqa.github.io/isort/) и [black](https://black.readthedocs.io/en/stable/) - отформатируют код согласно PEP-8 и вашим персональным настройкам.
- [flake8](https://flake8.pycqa.org/en/latest/) - проверяет код на соответствие PEP-8, имеет ряд расширений, подробнее о
  которых можно прочитать в документации, используемые в проекте указаны в `.pre-commit-config.yaml` файле.
- [mypy](https://www.mypy-lang.org) - проверка и рекомендации по тайпхинтинга

> Указать настройки линтеров и форматеров проще всего в файле `pyproject.toml`.
> Список используемых линтеров и их настройки всегда можно дополнить (или убрать лишнее).

### pre-commit

#### Установка pre-commit
```bash
pre-commit install
```

Теперь при создании коммита (`git commit -m 'Commit text'`) black и isort отформатируют код (при необходимости), flake8 проверит соответствие нормам PEP-8, а mypy - проверит тайпхинты. Вся информация по ошибкам и полям для исправления будет выведена в консоль.
> Для просто проверки кода и запуска линтеров и форматеров можно просто прописать `git commit`. Коммит при этом создан **НЕ** будет.

> **Для тех кто использует PyCharm:**
> 
> Можно создавать коммиты прям из графического интерфейса (`Commit->Commit`), pre-commit будет запущены. Информацию по их работе можно посмотреть во вкладке `Git(там где ветки) -> console`. 
> 
> **НО** запускать сразу `Commit and Push` **НЕ** следует, лично у меня pre-commit не отрабатывает, и все изменения сразу уходят на сервер, без проверок и форматирования. 

Да, возможно придется повторить не 1 раз :) Но в итоге мы получим чистый, отформатированный, протипизированный и в целом
красивый код, который поймет кто угодно!

[⬆️ К оглавлению](#оглавление)

## Alembic
Необходим для создания автоматических миграций из SQLAlchemy

### Команды:
> При выполнении миграций можно вводить вместо `head` просто `h`, `he` и тд., если так начинается название только одного файла миграций.
> 
> Аналогично можно применять revision id 
> 
> Также поддерживается относительное указание миграций: «выполнить две следующие миграции» или «откатить три предыдущие»; для этого после команд `upgrade` и `downgrade` нужно указать число со знаком плюс или минус: `alembic ugprade +2` или `alembic downgrade -3`


Создание новой миграции:
```bash
alembic revision --autogenerate -m "Migration Message"
```
> revision id можно указать вручную при помощи флага `--rev-id 01`

Выполнение всех неприменённых миграций:
```bash
alembic upgrade head 
```
> Для выполнений до конкретной миграции вместо head прописать revision id `befcaa650c3f`

Отменить всех миграций, которые были в проекте:
```bash
alembic downgrade base
```
> Для выполнений до конкретной миграции вместо head прописать revision id `466f1da3d4b1`

Хронология миграций в подробном виде:
```bash
alembic history -v 
```
> Rev: `befcaa650c3f` `(head)`                                                                                        
> Parent: `466f1da3d4b1`                                                                                            
> Path: `...\alembic\versions\befcaa650c3f_second_migration.py`
>                                                                                                                 
>     Add description to MeetingRoom                                                                              
>                                                                                                                 
>     Revision ID: befcaa650c3f                                                                                   
>     Revises: 466f1da3d4b1                                                                                       
>     Create Date: 2024-01-18 20:20:20.202020                                                                     
> 
> Rev: `466f1da3d4b1`
> Parent: `<base>`
> Path: `...\alembic\versions\466f1da3d4b1_first_migration.py`
> 
>     First migration
> 
>     Revision ID: 466f1da3d4b1
>     Revises:
>     Create Date: 2024-01-18 10:10:10.101010   

Просмотр последней применённой миграции:
```bash
alembic current 
```
> выводит revision id текущей миграции
> 
>     466f1da3d4b1 


[⬆️ К оглавлению](#оглавление)

## Работа с GIT:
Базовые моменты работы с GIT описывать смысла нет, поскольку все с ним знакомы и работали с ним.

### Нейминг веток

Обязательно работаем внутри ветки. Под каждую задачу своя ветка.

Начиная работу - создай новую ветку, в ней сделай свою фичу, залей на гит как будет готово.

**Паттерн для названия ветки:**

`feature/<task_name>` - для фич

`fix/<task_name>` - для фиксов


### Pull Request

По завершении работы над задачей, отправляем её на сервер и ждём подтверждения от workflow на соответствия кода нашим стандартам. После тегаем в телеграмме других разработчиков и ждём подтверждения минимум от 2х программистов. 

> Пушить после успешного ревью в ветку `develop` может любой разработчик. Пока нет ветки `develop`, можно пушить в `main` (создадим как будет первая версия приложения, которое можно заливать на сервер. При Push в ветку main будут запускаться workflows для deploy на сервер)

[⬆️ К оглавлению](#оглавление)

## Архитектура

Программа находится внутри папки `app`

1. **core**

Ядро программы. Конфигурационные файлы и management команды.

2. **api**

API для взаимодействия с frontend. Routers и endpoints.

4. **services**

Вынесенная бизнес логика приложения.

5. **models**

Модели на **SQLAlchemy**.

6. **schemas**

DTO модели (схемы) для общения между слоями приложения на **Pydantic**.

7. **crud**

Запросы к базе данных.

8. **tests**

Тесты приложения.

[⬆️ К оглавлению](#оглавление)

